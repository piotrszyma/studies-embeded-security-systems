\section{Problem set 4}
\subsection{Preface}

The goal of this problem set was to show practical examples of embedded systems.
During excercies I've learned how to setup a simple circuit using basic tools
like IR diodes, IR receivers, resistors and lot of wires. All of that was joined
and connected into \texttt{Arduino Uno} platform, which was connected to the PC
using \texttt{USB} port. I was able to create a simple programs using
\texttt{Arduino} platform to make everything work.

\subsection{Assignment}
\subsubsection{Requirements}
Goal of this assignment was to cooperate in pairs with a teammate and create a simple communication protocol between two \texttt{Arduino Uno} platforms connected to separate PCs. The requirementes for the protocol was the following:
\begin{itemize}
  \item Messages had to be encrypted
  \item A5/1 pseudorandom number generator (similar to the one we've created in previous problem sets) had to be used as a source of randomness
  \item Two mediums of communication had to be used - wire and wireless connection (cable and IR diode correspondingly)
\end{itemize}
\subsubsection{Idea}
Together with team mate we've decided to create a system with the following structure: before transmission, we've chosen one of Arduino to be ,,master'' and the other to be ,,slave''. This simplification allowed use to skip the master/slave setup phase of protocol, which, in our opinion, would be a little bit overkill for a system like this.

The goal of the ,,master'' Arduino, and actually that's the only thing that differentiante ,,master'' device from ,,slave'', is to generate 64 bits initialization vector for both devices pseudorandom generators and send it it to ,,slave'' machine (that is being done in the initialization phase).  We've decided to use the wire connection to be the one with which we send the initialization vector - we've assumed that physical connection between devices can be fully trusted and is appropriate for this task.

After initialization phase, both devices feed their A5/1 generators with same IV, what makes those pseudorandom generators generate same sequences of bits. Thanks to this property, one of the devices can generate a cypher by XORing next random bits with the message itself  \textit{(equation \ref{eq:1})} and the other one can decypher a cypher to get the content of message sent by the first device \textit{(equation \ref{eq:2})}.

\begin{equation} \label{eq:1} c = Enc_{A5/1}(m) \end{equation}
\begin{equation} \label{eq:2} m = Dec_{A5/1}(c) \end{equation}

Under the hood, for each symbol $s$ in the message $m$ \textit{(equation \ref{eq:3})}, encoded in \texttt{UTF-8} encoding (symbol $s_n$ got 8 bits $s_{nk}$ \textit{(equation \ref{eq:4})}), 8 bits  \textit{(equation \ref{eq:5})} generated by A5/1 were required to encrypt it.

\begin{equation} \label{eq:3} m = s_1 s_2 s_3 \dots s_n  \end{equation}
\begin{equation} \label{eq:4} s_n = s_{n1} s_{n2} s_{n3} \dots s_{n8}   \end{equation}

\begin{equation} \label{eq:5} PRNG_{out} \rightarrow r_{i}, r_{i+1}, r_{i+2}, r_{i+3}, r_{i+4}, r_{i+5}, r_{i+6}, r_{i+7} \end{equation}

Using output of A5/1 $PRNG_{out}$ and message symbol $s_n$ bits $s_{nk}$, a chunk of cypher $c_n$ were generated by \texttt{XOR}ing \textit{(equation \ref{eq:6})}.

\begin{equation} \label{eq:6} c_n = s_n \oplus PRNG_{out_{i, \dots, i+7}} = s_{n1} \oplus r_{i} || s_{n2} \oplus r_{i+1} \dots || s_{n8} \oplus r_{i+7}\end{equation}

In general, for message of length $l$ with each symbol having $8$ bits,
a $8l$ number of bits from A5/1 had to be use.

For decoding, very similar procedure was applied. For each encrypted symbol (having 8 bits), other device generated bit from A5/1 (which, as stated in the initial phase, was feeded with same IV) and xored each cyphertext symbol's bit $c_{nk}$ with the bit generated by second pseudorandom generator $r_{i}^{PRNG2}$. But we know, that $c_{nk}$ was generated by using ${r_{i}^{PRNG1}}$ and for both PRNG the $i$-th $r$ value is the same: ${r_{i}^{PRNG1}} = r_{i}^{PRNG2} = r_{i}$. In result, the other device decodes the message \textit{(equation \ref{eq:7})}.

\begin{equation} \label{eq:7} c_{nk} \oplus r_{i}^{PRNG2} = (m_{nk} \oplus r_{i}^{PRNG1}) \oplus r_{i}^{PRNG2} = m_{nk} \oplus r_{i} \oplus r_{i} = m_{nk}\end{equation}

\subsubsection{Arduino software implementation}
Both Arduinos, except from some basic logic for flow of data, were controlled using \texttt{Python} code on PCs. PC and Arduino communicated using \texttt{USB} serial. Additional part of Arduino logic was the \texttt{setup} phase on
,,master'' device which required the Python code to send random IV, which was later populated by ,,master'' Arduino to ,,slave'' using the wire connection. The later Arduino logic, code inside the Arduinos \texttt{loop}, simply sent all the data received from IR receiver and cable connection into the USB serial and populated all the data from USB Serial into the IR diode.

Listing \ref{fig:master-arduino-init} depics part of ,,master'' setup method that was waiting for the IV from PC on USB serial. After receving the IV, vector was sent using cable connection to slave.

\begin{minipage}{\linewidth}
\begin{lstlisting}[
  style=cpp,
  caption={,,Master'' setup phase},
  captionpos=b,
  label={fig:master-arduino-init}
]
  while(IVUnset){
    if (Serial.available()>0) {
      IV=Serial.readString();
      IVUnset=false;
      if(IV.length()==65){
        for(int i=0;i<64;i++){
          if(IV[i]!='0' && IV[i]!='1'){
            Serial.println("Wrong char");
            IVUnset=true;
            break;
          }
        }
      }else{
        Serial.println("Wrong len");
        IVUnset=true;
      }
    }
  }
\end{lstlisting}
\end{minipage}

For the rest of communication, both Arduinos were only populating the data, code responsible for that - content of \texttt{loop} method of both Arduinos, is showed on listing \ref{fig:arduinos-loop}. When Arduino detected some data in the cable input buffer (\texttt{communication} variable) or received by diode (\texttt{irrecv} variable), it resent it to the USB \texttt{Serial} - into PC. On any data received from PC (\texttt{Serial} variable), the data was converted into number from 2 byte (so one between $0$ and $2^{16} - 1$), and sent using \texttt{NEC} protocol via diode. What's worth mentioning, each of the long values were retransmitted 3 times (this is a part of protocol we used to ensure data transmitted using IR diode is not malformed and it will be described in details in the next part of report)

\begin{minipage}{\linewidth}
\begin{lstlisting}[
  style=cpp,
  caption={Arduinos loop phase},
  captionpos=b,
  label={fig:arduinos-loop}
]
void loop() {
  if(Serial.available()>0){
      Serial.readBytes(buffer, 2);
      data = bufferToInt(buffer);
      irsend.sendNEC(data, 32);
      delay(40);
      irsend.sendNEC(data, 32);
      delay(40);
      irsend.sendNEC(data, 32);
      delay(40);
      irrecv.enableIRIn();
  }
  if(communication.available()>0){
    Serial.println(communication.readString());
  }
  if (irrecv.decode(&results)) {
    Serial.println(results.value, BIN);
    irrecv.resume();
  }
}
\end{lstlisting}
\end{minipage}

\subsubsection{PC software implementation}
The crucial part of project, as Arduinos themselves are just for transmitting data from one source to another, is built in \texttt{Python} script on PC. The way of communication of PC script with each of Arduinos is USB port. The library used for communication was \texttt{pyserial}, which provides convenient public API that allows to connect with serial on port, send data into the serial and collect data from serial. Listing \ref{fig:python-pyserial-sample} contains simple methods provided by \texttt{pyserial} library that shows how the interaction with Ardunio looks in code.

\begin{lstlisting}[
  style=python,
  caption={\texttt{pyserial} basic communication},
  captionpos=b,
  label={fig:python-pyserial-sample}
]
import serial # pyserial library import

s = serial.Serial('/tty/USB01')  # connection initialization
s.write(bytes((255, 255)))  # sending bytes to serial
s.readline()  # reading line from serial
\end{lstlisting}

In the,,master'' method, python code generates random IV vector \textit{(Listing \ref{fig:python-master-iv})} and sends it using Serial to the Arduino. ,,Master'' Arduino sends it using cable connection. When the IV is being sent from ,,master'', the corresponding code in ,,slave'' \textit{(Listing \ref{fig:python-slave-iv})} waits for data from USB Serial. As mentioned earlier, ,,slave'' Arduino sends all the data received on cable connection to USB Serial, so the IV on ,,slave'' will be successfully received from ,,master''.

% Add listing from master that sends IV to Serial.
% Add listing from slave that waits for IV.

\begin{lstlisting}[
  style=python,
  caption={Master generates IV and sends it via Serial to slave.},
  captionpos=b,
  label={fig:python-master-iv}
]
with serial.Serial(port, 9600, timeout=0) as cable_serial:
  logging.info('Master generates IV.')
  iv = get_random_iv(IV_SIZE)
  iv_bytes_msg = bytes(iv + "\n", "UTF-8")
  logging.info(iv)
  logging.info('Master waits 2s...')
  time.sleep(2)
  logging.info('Master sends IV')
  cable_serial.write(iv_bytes_msg)
\end{lstlisting}

\begin{lstlisting}[
  style=python,
  caption={Slave waits for valid IV from master.},
  captionpos=b,
  label={fig:python-slave-iv}
]
with serial.Serial(port, 9600, timeout=2) as cable_serial:
  cable_serial.reset_input_buffer()
  while True:
    iv = cable_serial.read(64)
    logging.info(f'Slave reiceived IV value: {iv} of len {len(iv)}')

    if len(iv) == 64 and b'\r' not in iv and b'\n' not in iv:
      cable_serial.reset_input_buffer()
      cable_serial.reset_output_buffer()
      break
\end{lstlisting}

When IV value is established, both parts generates PRNG and master can send message. (Our assumption is that master is always the one that sends the message first) In the meantime, slave is expecting a message received from master. Basically, the whole send - receive procedure can work same way in the other direction. What's worth mention is how the encryption and decryption protocol with data check works under the hood. As we've discovered at the beginning of our work, IR connection had data malform issues quite often and the initial approach of sending all the cypher data byte by byte was not effective. Based on those problems we've decided to introduce verification part. In our protocol:

\begin{itemize}
  \item {All the messages can have length of at most 254 characters.}
  \item {All of the messages are sent in 2 bytes chunks - leftmost bits are counter (starting with 1) and rightmost are the values of cypher.}
  \item {Each of the chunk is being retransmitted 2 times - so transmitted 3 times alltogether. }
  \item { Counter value of 255 is restricted and means the end of message.}
\end{itemize}

On the receiver side, current counter value $ctr$ is monitored and only $ctr$, $ctr+1$ or $255$ are accepted. For value $ctr$ the cypher $c(ctr)$ is accepted as possible for $m_{possible}(ctr)$, for value $ctr+1$, $m(ctr)$ is evaluated from all $m_{possible}(ctr)$ values (that's called evaluation and it takes the most popular $m$ from set of $m_{possible}$ messages) and new evaluation is being started for $ctr+1$ (now $ctr+1$, $ctr+2$ or $255$ are accepted) and so on and so forth. When receiver encounters value $255$ it knows that the message has finished. Thanks to that procedure, when one of $X$ possible values for counter value $Y$ is malformed, then other $X - 1$ values, equal, with high probability, good cypher values, will win in the evaluation. In our protocol, for speed and still quite good ,,valid messages rate'' reasons, we've decided to send all the messages 3 times.

In the \texttt{Python} code, two methods, \texttt{send\_message} and
 \texttt{read\_message} encapsulate all the implementation details that are responsible for sending and receiving messages. The important thing is that when one party calls \texttt{send\_message} method (e. g. slave), the other have to call \texttt{read\_message} so the message will successfully be received (e. g. master).

 The \texttt{send\_message} method \textit{(Listing \ref{fig:python-send-message})} is simple and only encrypts, adds counter value and passes the cypher to Arduino (which sends it three times). The \texttt{read\_message} \textit{(Listing \ref{fig:python-read-message})} is much more sophisticated. First of all, it contains \texttt{read\_data} method that parses the input from Ardunio. Secondly, it has logic responsible for parsing incoming messages and their corresponding counters based on counter state so it can recreate the cypher from chunks. After receiving all chunks (got $ctr$ value $255$) it decrypts message by concatenating most popular of values for all chunks and applying bits` generated from A5/1. The decrypted message is being returned by the method.


 \begin{minipage}{\linewidth}
  \begin{lstlisting}[
   style=python,
   caption={Implementation of \texttt{send\_message} method.},
   captionpos=b,
   label={fig:python-send-message}
 ]
 def send_message(message_str, cable_serial, prng):
   encrypted_message = encrypt_message(message_str.encode('utf-8'), prng)
   for counter, message_byte in enumerate(encrypted_message, start=1):
     time.sleep(0.25)
     cable_serial.write(bytes((counter, message_byte,)))
   cable_serial.write(bytes((255, 255,)))
 \end{lstlisting}
 \end{minipage}

 \begin{minipage}{\linewidth}
  \begin{lstlisting}[
   style=python,
   caption={Implementation of \texttt{read\_message} method.},
   captionpos=b,
   label={fig:python-read-message}
 ]

 def read_message(cable_serial, prng):
  encrypted_msg = b''
  expected_ctr = 1
  frame_options = []
  synchronized = False
  while True:
    frame_letter, frame_ctr = read_data(cable_serial)

    if frame_ctr == 255:
      encrypted_msg += max(
          set(frame_options),
          key=frame_options.count).to_bytes(length=1, byteorder='big')
      logging.info('End of message detected once.')
      decrypted_msg = decrypt_message(encrypted_msg, prng)
      return decrypted_msg

    if not synchronized and frame_ctr != 1:
      logging.info(f'Not synchronized and ctr: {frame_ctr},'
                    ' expected ctr: {expected_ctr}')
      continue

    if not synchronized:
      logging.info(f'frame_ctr: {frame_ctr}, moving into synchronized state.')
      synchronized = True
    if frame_ctr == expected_ctr:
      logging.info(f'frame_ctr: {frame_ctr} == expected_ctr, '
                    'adding option for nr {frame_ctr}.')
      frame_options.append(frame_letter)
    elif frame_ctr == expected_ctr + 1:
      logging.info(f'frame_ctr: {frame_ctr} == expected_ctr + 1, '
                    'evaluating, initializing new options for nr {frame_ctr}.')
      encrypted_msg += max(
        set(frame_options),
        key=frame_options.count).to_bytes(length=1, byteorder='big')
      frame_options = [frame_letter]
      expected_ctr += 1
    else: # Not current_ctr, not current_ctr + 1
      logging.info(f'Neither expected_ctr ({expected_ctr}) '
                    'or expected_ctr + 1, but {frame_ctr}')
      continue
 \end{lstlisting}
 \end{minipage}

% Add listing of implementations of send_message and receive_message

 \subsubsection{Hardware implementation}
The hardware for our assignment contained of two Arduinos Uno with external IR diode and IR receiver connected to pins. Moreover, both Arduinos shared two wires to enable two way wire communication. Each of the Arduinos was controlled via the USB cable with PC machines running \texttt{Python} scripts.

IR diode (transmitter) used in the system was \texttt{LIRED5B-880 5mm 880nm} that sends waves of length 880 nm ($880 \times 10^{-9}$ m). The receiver used to intercept IR signal was \texttt{TSOP 4838} working with frequency up to $38 kHz$. To control the power source - Arduino - carbon resistor was used with the resistance of $220 \Omega.$

% Add circuit project.

\subsubsection{Paralellel cypher and secret transmission}
The case mentioned above was not the only one required to implement. The second case, similar in most practical aspects, was about parallel transmissions using both wire and wireless connections. In that case we've modified code of our Arduino logic and Python program from case 1 so that the source of transmission was only master. When master sends message (using \texttt{send\_message} method), the logic under the hood, for each symbol in the message, generates cypher (in a simmiliar manner to the first case) and sends - the single encrypted character using IR diode and bits generated from A5/1 used to XOR with original character. For the slave entity, \texttt{read\_message} was used. It expected to receive single message both via the wire connection and wireless one. The way Python code distinguished messages received on Serial was that the IR receiver output was prefixed with ,,\texttt{C:}'' and wire output was prefixed with ,,\texttt{S:}''.

\subsubsection{Pseudorandom number generator}
For the task of pseudorandom numbers generation, a Python implementation of A5/1 pseudorandom number generator was introduced. Source of code implementation is attached on Listing \ref{fig:python-prng}.

\begin{minipage}{\linewidth}
  \begin{lstlisting}[
   style=python,
   caption={Implementation of \texttt{a51} PRNG used to generate pseudorandom numbers.},
   captionpos=b,
   label={fig:python-prng}
 ]
class A51:
  def __init__(self, seed):
    assert len(seed) == 64
    self.lsfr1 = seed[:19]
    self.lsfr2 = seed[19:-23]
    self.lsfr3 = seed[-23:]

  def shift_lsfrs(self):
    voting_bits = self.lsfr1[8], self.lsfr2[10], self.lsfr3[10]
    majority_bit = max(set(voting_bits), key=voting_bits.count)
    if self.lsfr1[8] == majority_bit:
      self.lsfr1 = [
        self.lsfr1[18] ^ self.lsfr1[17] ^ self.lsfr1[16] ^ self.lsfr1[13],
        *self.lsfr1[:-1]
      ]
    if self.lsfr2[10] == majority_bit:
      self.lsfr2 = [self.lsfr2[21] ^ self.lsfr2[20], *self.lsfr2[:-1]]
    if self.lsfr3[10] == majority_bit:
      self.lsfr3 = [
        self.lsfr3[22] ^ self.lsfr3[21] ^ self.lsfr3[20] ^ self.lsfr3[7],
        *self.lsfr3[:-1]
      ]

  def __iter__(self):
    return self

  def __next__(self):
    self.shift_lsfrs()
    return self.lsfr1[-1] ^ self.lsfr2[-1] ^ self.lsfr3[-1]
  \end{lstlisting}
\end{minipage}